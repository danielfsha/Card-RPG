#![no_std]

//! # Fog of War Chess - Production Implementation
//!
//! A two-player chess game with fog of war mechanics using Zero-Knowledge proofs.
//! Players can only see their own pieces and squares within their line of sight.
//! Moves are validated using ZK proofs generated by Noir circuits and verified on-chain using BN254.
//!
//! **Game Hub Integration:**
//! This game is Game Hub-aware and enforces all games to be played through the
//! Game Hub contract. Games cannot be started or completed without points involvement.

mod verifier;

use soroban_sdk::{
    contract, contractclient, contracterror, contractimpl, contracttype,
    Address, BytesN, Env, IntoVal, Vec, vec,
};

use verifier::{parse_proof, parse_public_signals, parse_verification_key, verify_groth16_proof};

// Import GameHub contract interface
#[contractclient(name = "GameHubClient")]
pub trait GameHub {
    fn start_game(
        env: Env,
        game_id: Address,
        session_id: u32,
        player1: Address,
        player2: Address,
        player1_points: i128,
        player2_points: i128,
    );

    fn end_game(env: Env, session_id: u32, player1_won: bool);
}

// ============================================================================
// Constants
// ============================================================================

/// TTL for game storage (30 days in ledgers, ~5 seconds per ledger)
const GAME_TTL_LEDGERS: u32 = 518_400;

/// Maximum moves per game (to prevent infinite games)
const MAX_MOVES: u32 = 500;

/// Move timeout in ledgers (~5 minutes = 60 ledgers)
const MOVE_TIMEOUT_LEDGERS: u32 = 60;

// ============================================================================
// Errors
// ============================================================================

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
#[repr(u32)]
pub enum Error {
    GameNotFound = 1,
    NotPlayer = 2,
    NotYourTurn = 3,
    GameAlreadyEnded = 4,
    InvalidProof = 5,
    InvalidMove = 6,
    InvalidBoardCommitment = 7,
    KingInCheck = 8,
    MoveTimeout = 9,
    MaxMovesReached = 10,
    InvalidSquare = 11,
    InvalidProofFormat = 12,
    VerificationKeyNotSet = 13,
}

// ============================================================================
// Data Types
// ============================================================================

/// Groth16 proof for BN254 curve
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Groth16Proof {
    pub pi_a: BytesN<64>,      // G1 point (2 * 32 bytes)
    pub pi_b: BytesN<128>,     // G2 point (4 * 32 bytes)
    pub pi_c: BytesN<64>,      // G1 point (2 * 32 bytes)
}

/// ZK Proof with public inputs
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ZKProof {
    pub proof: Groth16Proof,
    pub public_inputs: Vec<BytesN<32>>,
}

/// Chess move with ZK proof
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ChessMove {
    pub from_square: u32,  // Changed from u8 to u32
    pub to_square: u32,    // Changed from u8 to u32
    pub move_hash: BytesN<32>,
    pub is_capture: bool,
    pub is_check: bool,
    pub is_checkmate: bool,
    pub proof: ZKProof,
    pub timestamp: u64,
}

/// Verification key for Groth16
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct VerificationKey {
    pub alpha: BytesN<64>,
    pub beta: BytesN<128>,
    pub gamma: BytesN<128>,
    pub delta: BytesN<128>,
    pub ic: Vec<BytesN<64>>,  // IC points for public inputs
}

/// Game state
#[contracttype]
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Game {
    pub player1: Address,
    pub player2: Address,
    pub player1_points: i128,
    pub player2_points: i128,
    pub white_board_commitment: BytesN<32>,
    pub black_board_commitment: BytesN<32>,
    pub current_turn: u32,  // Changed from u8 to u32
    pub move_count: u32,
    pub last_move_ledger: u32,
    pub winner: Option<Address>,
    pub game_over: bool,
    pub draw_offered_by: Option<Address>,
}

#[contracttype]
#[derive(Clone)]
pub enum DataKey {
    Game(u32),
    Move(u32, u32),
    GameHubAddress,
    Admin,
    VerificationKey,
}

// ============================================================================
// Contract Definition
// ============================================================================

#[contract]
pub struct FogOfWarChessContract;

#[contractimpl]
impl FogOfWarChessContract {
    /// Initialize the contract with GameHub address, admin, and verification key
    pub fn __constructor(
        env: Env,
        admin: Address,
        game_hub: Address,
        verification_key: VerificationKey,
    ) {
        env.storage().instance().set(&DataKey::Admin, &admin);
        env.storage()
            .instance()
            .set(&DataKey::GameHubAddress, &game_hub);
        env.storage()
            .instance()
            .set(&DataKey::VerificationKey, &verification_key);
    }

    /// Update verification key (admin only)
    pub fn set_verification_key(env: Env, verification_key: VerificationKey) -> Result<(), Error> {
        let admin: Address = env
            .storage()
            .instance()
            .get(&DataKey::Admin)
            .expect("Admin not set");
        admin.require_auth();

        env.storage()
            .instance()
            .set(&DataKey::VerificationKey, &verification_key);

        Ok(())
    }

    /// Start a new chess game
    pub fn start_game(
        env: Env,
        session_id: u32,
        player1: Address,
        player2: Address,
        player1_points: i128,
        player2_points: i128,
        white_board_commitment: BytesN<32>,
        black_board_commitment: BytesN<32>,
    ) -> Result<(), Error> {
        // Prevent self-play
        if player1 == player2 {
            panic!("Cannot play against yourself");
        }

        // Require authentication from both players
        player1.require_auth_for_args(vec![
            &env,
            session_id.into_val(&env),
            player1_points.into_val(&env),
        ]);
        player2.require_auth_for_args(vec![
            &env,
            session_id.into_val(&env),
            player2_points.into_val(&env),
        ]);

        // Get GameHub address
        let game_hub_addr: Address = env
            .storage()
            .instance()
            .get(&DataKey::GameHubAddress)
            .expect("GameHub address not set");

        // Create GameHub client
        let game_hub = GameHubClient::new(&env, &game_hub_addr);

        // Call Game Hub to start the session and lock points
        game_hub.start_game(
            &env.current_contract_address(),
            &session_id,
            &player1,
            &player2,
            &player1_points,
            &player2_points,
        );

        // Create game
        let game = Game {
            player1: player1.clone(),
            player2: player2.clone(),
            player1_points,
            player2_points,
            white_board_commitment,
            black_board_commitment,
            current_turn: 0,
            move_count: 0,
            last_move_ledger: env.ledger().sequence(),
            winner: None,
            game_over: false,
            draw_offered_by: None,
        };

        // Store game in temporary storage with 30-day TTL
        let game_key = DataKey::Game(session_id);
        env.storage().temporary().set(&game_key, &game);
        env.storage()
            .temporary()
            .extend_ttl(&game_key, GAME_TTL_LEDGERS, GAME_TTL_LEDGERS);

        Ok(())
    }

    /// Make a move with ZK proof
    pub fn make_move(
        env: Env,
        session_id: u32,
        player: Address,
        chess_move: ChessMove,
        new_board_commitment: BytesN<32>,
    ) -> Result<(), Error> {
        player.require_auth();

        // Validate square indices
        if chess_move.from_square >= 64 || chess_move.to_square >= 64 {
            return Err(Error::InvalidSquare);
        }

        // Get game from temporary storage
        let key = DataKey::Game(session_id);
        let mut game: Game = env
            .storage()
            .temporary()
            .get(&key)
            .ok_or(Error::GameNotFound)?;

        // Check game is still active
        if game.game_over {
            return Err(Error::GameAlreadyEnded);
        }

        // Check max moves
        if game.move_count >= MAX_MOVES {
            return Err(Error::MaxMovesReached);
        }

        // Check move timeout
        let current_ledger = env.ledger().sequence();
        if current_ledger > game.last_move_ledger + MOVE_TIMEOUT_LEDGERS {
            // Timeout - opponent wins
            let opponent = if player == game.player1 {
                game.player2.clone()
            } else {
                game.player1.clone()
            };
            return Self::end_game_internal(env, session_id, opponent, &mut game);
        }

        // Verify it's the player's turn
        let is_white = player == game.player1;
        let is_black = player == game.player2;

        if !is_white && !is_black {
            return Err(Error::NotPlayer);
        }

        let expected_turn = if is_white { 0 } else { 1 };
        if game.current_turn != expected_turn {
            return Err(Error::NotYourTurn);
        }

        // Verify ZK proof
        Self::verify_move_proof(&env, &game, &chess_move, is_white)?;

        // Update board commitment
        if is_white {
            game.white_board_commitment = new_board_commitment;
        } else {
            game.black_board_commitment = new_board_commitment;
        }

        // Store move
        let move_key = DataKey::Move(session_id, game.move_count);
        env.storage().temporary().set(&move_key, &chess_move);
        env.storage()
            .temporary()
            .extend_ttl(&move_key, GAME_TTL_LEDGERS, GAME_TTL_LEDGERS);

        // Check for checkmate
        if chess_move.is_checkmate {
            game.winner = Some(player.clone());
            game.game_over = true;

            // Store updated game
            env.storage().temporary().set(&key, &game);

            // Report to Game Hub
            let game_hub_addr: Address = env
                .storage()
                .instance()
                .get(&DataKey::GameHubAddress)
                .expect("GameHub address not set");
            let game_hub = GameHubClient::new(&env, &game_hub_addr);
            let player1_won = player == game.player1;
            game_hub.end_game(&session_id, &player1_won);

            return Ok(());
        }

        // Update turn
        game.current_turn = if game.current_turn == 0 { 1 } else { 0 };
        game.move_count += 1;
        game.last_move_ledger = current_ledger;
        game.draw_offered_by = None; // Clear draw offer after move

        // Store updated game
        env.storage().temporary().set(&key, &game);
        env.storage()
            .temporary()
            .extend_ttl(&key, GAME_TTL_LEDGERS, GAME_TTL_LEDGERS);

        Ok(())
    }

    /// Offer a draw
    pub fn offer_draw(env: Env, session_id: u32, player: Address) -> Result<(), Error> {
        player.require_auth();

        let key = DataKey::Game(session_id);
        let mut game: Game = env
            .storage()
            .temporary()
            .get(&key)
            .ok_or(Error::GameNotFound)?;

        if game.game_over {
            return Err(Error::GameAlreadyEnded);
        }

        if player != game.player1 && player != game.player2 {
            return Err(Error::NotPlayer);
        }

        game.draw_offered_by = Some(player);

        env.storage().temporary().set(&key, &game);
        env.storage()
            .temporary()
            .extend_ttl(&key, GAME_TTL_LEDGERS, GAME_TTL_LEDGERS);

        Ok(())
    }

    /// Accept a draw offer
    pub fn accept_draw(env: Env, session_id: u32, player: Address) -> Result<(), Error> {
        player.require_auth();

        let key = DataKey::Game(session_id);
        let mut game: Game = env
            .storage()
            .temporary()
            .get(&key)
            .ok_or(Error::GameNotFound)?;

        if game.game_over {
            return Err(Error::GameAlreadyEnded);
        }

        // Check if draw was offered by opponent
        if let Some(offerer) = &game.draw_offered_by {
            if offerer == &player {
                return Err(Error::NotPlayer); // Can't accept your own draw offer
            }
        } else {
            return Err(Error::InvalidMove); // No draw offer to accept
        }

        // Game ends in draw - split points
        game.game_over = true;
        game.winner = None;

        env.storage().temporary().set(&key, &game);

        // Note: For draws, we don't call game_hub.end_game() as there's no winner
        // The Game Hub would need a separate draw_game() method

        Ok(())
    }

    /// Resign from the game
    pub fn resign(env: Env, session_id: u32, player: Address) -> Result<Address, Error> {
        player.require_auth();

        let key = DataKey::Game(session_id);
        let mut game: Game = env
            .storage()
            .temporary()
            .get(&key)
            .ok_or(Error::GameNotFound)?;

        if game.game_over {
            return Err(Error::GameAlreadyEnded);
        }

        if player != game.player1 && player != game.player2 {
            return Err(Error::NotPlayer);
        }

        // Opponent wins
        let winner = if player == game.player1 {
            game.player2.clone()
        } else {
            game.player1.clone()
        };

        Self::end_game_internal(env, session_id, winner.clone(), &mut game)?;

        Ok(winner)
    }

    /// Claim victory by timeout
    pub fn claim_timeout_victory(
        env: Env,
        session_id: u32,
        player: Address,
    ) -> Result<Address, Error> {
        player.require_auth();

        let key = DataKey::Game(session_id);
        let mut game: Game = env
            .storage()
            .temporary()
            .get(&key)
            .ok_or(Error::GameNotFound)?;

        if game.game_over {
            return Err(Error::GameAlreadyEnded);
        }

        if player != game.player1 && player != game.player2 {
            return Err(Error::NotPlayer);
        }

        // Check if opponent has timed out
        let current_ledger = env.ledger().sequence();
        if current_ledger <= game.last_move_ledger + MOVE_TIMEOUT_LEDGERS {
            return Err(Error::MoveTimeout);
        }

        Self::end_game_internal(env, session_id, player.clone(), &mut game)?;

        Ok(player)
    }

    /// Get game state
    pub fn get_game(env: Env, session_id: u32) -> Result<Game, Error> {
        let key = DataKey::Game(session_id);
        env.storage()
            .temporary()
            .get(&key)
            .ok_or(Error::GameNotFound)
    }

    /// Get a specific move
    pub fn get_move(env: Env, session_id: u32, move_number: u32) -> Result<ChessMove, Error> {
        let key = DataKey::Move(session_id, move_number);
        env.storage()
            .temporary()
            .get(&key)
            .ok_or(Error::GameNotFound)
    }

    /// Get move history
    pub fn get_move_history(
        env: Env,
        session_id: u32,
        start: u32,
        count: u32,
    ) -> Result<Vec<ChessMove>, Error> {
        let mut moves = vec![&env];

        for i in start..(start + count) {
            if let Ok(chess_move) = Self::get_move(env.clone(), session_id, i) {
                moves.push_back(chess_move);
            } else {
                break;
            }
        }

        Ok(moves)
    }

    // ========================================================================
    // Internal Functions
    // ========================================================================

    fn end_game_internal(
        env: Env,
        session_id: u32,
        winner: Address,
        game: &mut Game,
    ) -> Result<(), Error> {
        game.winner = Some(winner.clone());
        game.game_over = true;

        let key = DataKey::Game(session_id);
        env.storage().temporary().set(&key, game);

        // Report to Game Hub
        let game_hub_addr: Address = env
            .storage()
            .instance()
            .get(&DataKey::GameHubAddress)
            .expect("GameHub address not set");
        let game_hub = GameHubClient::new(&env, &game_hub_addr);
        let player1_won = winner == game.player1;
        game_hub.end_game(&session_id, &player1_won);

        Ok(())
    }

    fn verify_move_proof(
        env: &Env,
        game: &Game,
        chess_move: &ChessMove,
        is_white: bool,
    ) -> Result<(), Error> {
        // Get the current board commitment
        let board_commitment = if is_white {
            &game.white_board_commitment
        } else {
            &game.black_board_commitment
        };

        // Verify public inputs format
        if chess_move.proof.public_inputs.len() < 4 {
            return Err(Error::InvalidProofFormat);
        }

        // Verify board commitment matches
        if &chess_move.proof.public_inputs.get(0).unwrap() != board_commitment {
            return Err(Error::InvalidBoardCommitment);
        }

        // Verify move hash matches
        if &chess_move.proof.public_inputs.get(1).unwrap() != &chess_move.move_hash {
            return Err(Error::InvalidMove);
        }

        // Get verification key
        let vk: VerificationKey = env
            .storage()
            .instance()
            .get(&DataKey::VerificationKey)
            .ok_or(Error::VerificationKeyNotSet)?;

        // Verify Groth16 proof using BN254
        Self::verify_groth16(env, &vk, &chess_move.proof)?;

        Ok(())
    }

    fn verify_groth16(_env: &Env, vk: &VerificationKey, proof: &ZKProof) -> Result<(), Error> {
        // Parse verification key
        let parsed_vk = parse_verification_key(_env, vk)?;

        // Parse proof
        let parsed_proof = parse_proof(_env, &proof.proof)?;

        // Parse public signals
        let pub_signals = parse_public_signals(_env, &proof.public_inputs);

        // Verify the proof using BN254 pairing check
        let is_valid = verify_groth16_proof(_env, parsed_vk, parsed_proof, pub_signals)?;

        if !is_valid {
            return Err(Error::InvalidProof);
        }

        Ok(())
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod test;
