# Fog of War Chess - Soroban Contract

A two-player chess game with fog of war mechanics on Stellar, using Zero-Knowledge proofs for move validation.

## Overview

This contract implements fog of war chess where players can only see their own pieces and squares within their line of sight. Moves are validated using ZK proofs generated by Noir circuits, ensuring players cannot cheat while maintaining privacy.

## Features

- **Fog of War**: Players only see their pieces and visible squares
- **ZK Move Validation**: Moves proven valid without revealing board state
- **Game Hub Integration**: Points-based gameplay with Stellar Game Hub
- **On-Chain Verification**: Proofs verified on Stellar blockchain
- **Move History**: All moves stored with proofs for replay/verification

## Game Flow

### 1. Start Game

```rust
start_game(
    session_id: u32,
    player1: Address,      // White
    player2: Address,      // Black
    player1_points: i128,
    player2_points: i128,
    white_board_commitment: BytesN<32>,
    black_board_commitment: BytesN<32>,
)
```

Both players commit to their initial board state (standard chess starting position).

### 2. Make Moves

```rust
make_move(
    session_id: u32,
    player: Address,
    chess_move: Move,
    new_board_commitment: BytesN<32>,
)
```

Each move includes:
- Source and destination squares
- Move hash
- Capture and check flags
- ZK proof of validity
- New board commitment

### 3. Claim Victory

```rust
claim_victory(
    session_id: u32,
    winner: Address,
    reason: u8,  // 0=checkmate, 1=resignation, 2=timeout
)
```

Winner claims victory and Game Hub distributes points.

## Data Structures

### Game State

```rust
pub struct Game {
    pub player1: Address,       // White
    pub player2: Address,       // Black
    pub player1_points: i128,
    pub player2_points: i128,
    pub white_board_commitment: BytesN<32>,
    pub black_board_commitment: BytesN<32>,
    pub current_turn: u8,       // 0=white, 1=black
    pub move_count: u32,
    pub winner: Option<Address>,
    pub game_over: bool,
}
```

### Move

```rust
pub struct Move {
    pub from_square: u8,        // 0-63
    pub to_square: u8,          // 0-63
    pub move_hash: BytesN<32>,
    pub is_capture: bool,
    pub is_check: bool,
    pub proof: ZKProof,
}
```

### ZK Proof

```rust
pub struct ZKProof {
    pub proof: Bytes,           // Serialized Groth16 proof
    pub public_inputs: Vec<BytesN<32>>,
}
```

## Error Codes

```rust
pub enum Error {
    GameNotFound = 1,
    NotPlayer = 2,
    NotYourTurn = 3,
    GameAlreadyEnded = 4,
    InvalidProof = 5,
    InvalidMove = 6,
    InvalidBoardCommitment = 7,
    KingInCheck = 8,
}
```

## Storage

### Temporary Storage (30-day TTL)

- `Game(session_id)` - Game state
- `Move(session_id, move_number)` - Individual moves

### Instance Storage

- `Admin` - Contract admin address
- `GameHubAddress` - Game Hub contract address

## Building & Deployment

### Build Contract

```bash
# From repo root
bun run build chess
```

### Deploy to Testnet

```bash
bun run deploy chess
```

### Generate Bindings

```bash
bun run bindings chess
```

## Integration with Noir Circuits

### Proof Generation (Frontend)

```typescript
import { generateMoveProof } from './noir-chess';

// Generate proof for move
const proof = await generateMoveProof({
  boardState: currentBoard,
  fromSquare: 12,  // e2
  toSquare: 28,    // e4
  pieceType: PAWN,
  pieceColor: WHITE,
  salt: boardSalt,
});

// Submit move to contract
await chessContract.make_move({
  session_id: sessionId,
  player: playerAddress,
  chess_move: {
    from_square: 12,
    to_square: 28,
    move_hash: proof.moveHash,
    is_capture: false,
    is_check: false,
    proof: {
      proof: proof.proof,
      public_inputs: proof.publicInputs,
    },
  },
  new_board_commitment: newCommitment,
});
```

### Proof Verification (Contract)

The contract verifies:
1. Board commitment matches public input
2. Move hash matches public input
3. Proof is valid (Groth16 verification)
4. Player is authorized
5. It's player's turn

## Game Hub Integration

### Start Game

Contract calls `game_hub.start_game()` to:
- Lock player points
- Create session
- Emit GameStarted event

### End Game

Contract calls `game_hub.end_game()` to:
- Distribute points to winner
- Close session
- Emit GameEnded event

## Security Considerations

### Commitment Security

- Board commitments use Pedersen hash
- Salt prevents rainbow table attacks
- Binding property prevents board changes

### Proof Security

- Groth16 proofs are succinct and zero-knowledge
- Invalid moves cannot generate valid proofs
- Proofs reveal only move validity, not board state

### Game Integrity

- Cannot make illegal moves
- Cannot see opponent's hidden pieces
- Cannot fake captures or checks
- Move history is immutable

## Testing

```bash
# Run contract tests
cd contracts/chess
cargo test
```

## Frontend Integration

See `chess-frontend/` for React frontend with:
- 3D chess board visualization
- Fog of war rendering
- ZK proof generation
- Stellar wallet integration

## Future Enhancements

1. **Time Controls**: Add chess clocks
2. **Draw Offers**: Implement draw by agreement
3. **Threefold Repetition**: Detect repeated positions
4. **50-Move Rule**: Automatic draw detection
5. **Rating System**: ELO-based player ratings
6. **Tournament Mode**: Multi-player tournaments
7. **Replay System**: Analyze past games

## References

- **Stellar Soroban**: https://soroban.stellar.org/
- **Game Hub**: See `contracts/mock-game-hub/`
- **Noir Circuits**: See `circuits/chess/`
- **FIDE Rules**: https://www.fide.com/FIDE/handbook/LawsOfChess.pdf

## License

MIT
